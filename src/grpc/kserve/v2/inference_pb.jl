# Autogenerated using ProtoBuf.jl v1.1.1 on 2025-07-07T20:05:45.751
# original file: /home/rbellamy/Development/rbellamy/RxInferKServe.jl/proto/kserve/v2/inference.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export ModelMetadataRequest, ServerReadyRequest, var"ModelMetadataResponse.TensorMetadata"
export InferParameter, ServerLiveResponse, ModelReadyResponse, InferTensorContents
export ServerLiveRequest, ServerReadyResponse, ServerMetadataRequest
export ServerMetadataResponse, ModelReadyRequest, ModelMetadataResponse
export var"ModelInferRequest.InferRequestedOutputTensor"
export var"ModelInferRequest.InferInputTensor", var"ModelInferResponse.InferOutputTensor"
export ModelInferRequest, ModelInferResponse


struct ModelMetadataRequest
    name::String
    version::String
end
PB.default_values(::Type{ModelMetadataRequest}) = (;name = "", version = "")
PB.field_numbers(::Type{ModelMetadataRequest}) = (;name = 1, version = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ModelMetadataRequest})
    name = ""
    version = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            version = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return ModelMetadataRequest(name, version)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ModelMetadataRequest)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.version) && PB.encode(e, 2, x.version)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ModelMetadataRequest)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.version) && (encoded_size += PB._encoded_size(x.version, 2))
    return encoded_size
end

struct ServerReadyRequest end

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ServerReadyRequest})
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        PB.skip(d, wire_type)
    end
    return ServerReadyRequest()
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ServerReadyRequest)
    initpos = position(e.io)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ServerReadyRequest)
    encoded_size = 0
    return encoded_size
end

struct var"ModelMetadataResponse.TensorMetadata"
    name::String
    datatype::String
    shape::Vector{Int64}
end
PB.default_values(::Type{var"ModelMetadataResponse.TensorMetadata"}) = (;name = "", datatype = "", shape = Vector{Int64}())
PB.field_numbers(::Type{var"ModelMetadataResponse.TensorMetadata"}) = (;name = 1, datatype = 2, shape = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"ModelMetadataResponse.TensorMetadata"})
    name = ""
    datatype = ""
    shape = PB.BufferedVector{Int64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            datatype = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, wire_type, shape)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"ModelMetadataResponse.TensorMetadata"(name, datatype, shape[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"ModelMetadataResponse.TensorMetadata")
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.datatype) && PB.encode(e, 2, x.datatype)
    !isempty(x.shape) && PB.encode(e, 3, x.shape)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"ModelMetadataResponse.TensorMetadata")
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.datatype) && (encoded_size += PB._encoded_size(x.datatype, 2))
    !isempty(x.shape) && (encoded_size += PB._encoded_size(x.shape, 3))
    return encoded_size
end

struct InferParameter
    parameter_choice::Union{Nothing,OneOf{<:Union{Bool,Int64,String}}}
end
PB.oneof_field_types(::Type{InferParameter}) = (;
    parameter_choice = (;bool_param=Bool, int64_param=Int64, string_param=String),
)
PB.default_values(::Type{InferParameter}) = (;bool_param = false, int64_param = zero(Int64), string_param = "")
PB.field_numbers(::Type{InferParameter}) = (;bool_param = 1, int64_param = 2, string_param = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:InferParameter})
    parameter_choice = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            parameter_choice = OneOf(:bool_param, PB.decode(d, Bool))
        elseif field_number == 2
            parameter_choice = OneOf(:int64_param, PB.decode(d, Int64))
        elseif field_number == 3
            parameter_choice = OneOf(:string_param, PB.decode(d, String))
        else
            PB.skip(d, wire_type)
        end
    end
    return InferParameter(parameter_choice)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::InferParameter)
    initpos = position(e.io)
    if isnothing(x.parameter_choice);
    elseif x.parameter_choice.name === :bool_param
        PB.encode(e, 1, x.parameter_choice[]::Bool)
    elseif x.parameter_choice.name === :int64_param
        PB.encode(e, 2, x.parameter_choice[]::Int64)
    elseif x.parameter_choice.name === :string_param
        PB.encode(e, 3, x.parameter_choice[]::String)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::InferParameter)
    encoded_size = 0
    if isnothing(x.parameter_choice);
    elseif x.parameter_choice.name === :bool_param
        encoded_size += PB._encoded_size(x.parameter_choice[]::Bool, 1)
    elseif x.parameter_choice.name === :int64_param
        encoded_size += PB._encoded_size(x.parameter_choice[]::Int64, 2)
    elseif x.parameter_choice.name === :string_param
        encoded_size += PB._encoded_size(x.parameter_choice[]::String, 3)
    end
    return encoded_size
end

struct ServerLiveResponse
    live::Bool
end
PB.default_values(::Type{ServerLiveResponse}) = (;live = false)
PB.field_numbers(::Type{ServerLiveResponse}) = (;live = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ServerLiveResponse})
    live = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            live = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return ServerLiveResponse(live)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ServerLiveResponse)
    initpos = position(e.io)
    x.live != false && PB.encode(e, 1, x.live)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ServerLiveResponse)
    encoded_size = 0
    x.live != false && (encoded_size += PB._encoded_size(x.live, 1))
    return encoded_size
end

struct ModelReadyResponse
    ready::Bool
end
PB.default_values(::Type{ModelReadyResponse}) = (;ready = false)
PB.field_numbers(::Type{ModelReadyResponse}) = (;ready = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ModelReadyResponse})
    ready = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            ready = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return ModelReadyResponse(ready)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ModelReadyResponse)
    initpos = position(e.io)
    x.ready != false && PB.encode(e, 1, x.ready)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ModelReadyResponse)
    encoded_size = 0
    x.ready != false && (encoded_size += PB._encoded_size(x.ready, 1))
    return encoded_size
end

struct InferTensorContents
    bool_contents::Vector{Bool}
    int_contents::Vector{Int32}
    int64_contents::Vector{Int64}
    uint_contents::Vector{UInt32}
    uint64_contents::Vector{UInt64}
    fp32_contents::Vector{Float32}
    fp64_contents::Vector{Float64}
    bytes_contents::Vector{Vector{UInt8}}
end
PB.default_values(::Type{InferTensorContents}) = (;bool_contents = Vector{Bool}(), int_contents = Vector{Int32}(), int64_contents = Vector{Int64}(), uint_contents = Vector{UInt32}(), uint64_contents = Vector{UInt64}(), fp32_contents = Vector{Float32}(), fp64_contents = Vector{Float64}(), bytes_contents = Vector{Vector{UInt8}}())
PB.field_numbers(::Type{InferTensorContents}) = (;bool_contents = 1, int_contents = 2, int64_contents = 3, uint_contents = 4, uint64_contents = 5, fp32_contents = 6, fp64_contents = 7, bytes_contents = 8)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:InferTensorContents})
    bool_contents = PB.BufferedVector{Bool}()
    int_contents = PB.BufferedVector{Int32}()
    int64_contents = PB.BufferedVector{Int64}()
    uint_contents = PB.BufferedVector{UInt32}()
    uint64_contents = PB.BufferedVector{UInt64}()
    fp32_contents = PB.BufferedVector{Float32}()
    fp64_contents = PB.BufferedVector{Float64}()
    bytes_contents = PB.BufferedVector{Vector{UInt8}}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, bool_contents)
        elseif field_number == 2
            PB.decode!(d, wire_type, int_contents)
        elseif field_number == 3
            PB.decode!(d, wire_type, int64_contents)
        elseif field_number == 4
            PB.decode!(d, wire_type, uint_contents)
        elseif field_number == 5
            PB.decode!(d, wire_type, uint64_contents)
        elseif field_number == 6
            PB.decode!(d, wire_type, fp32_contents)
        elseif field_number == 7
            PB.decode!(d, wire_type, fp64_contents)
        elseif field_number == 8
            PB.decode!(d, bytes_contents)
        else
            PB.skip(d, wire_type)
        end
    end
    return InferTensorContents(bool_contents[], int_contents[], int64_contents[], uint_contents[], uint64_contents[], fp32_contents[], fp64_contents[], bytes_contents[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::InferTensorContents)
    initpos = position(e.io)
    !isempty(x.bool_contents) && PB.encode(e, 1, x.bool_contents)
    !isempty(x.int_contents) && PB.encode(e, 2, x.int_contents)
    !isempty(x.int64_contents) && PB.encode(e, 3, x.int64_contents)
    !isempty(x.uint_contents) && PB.encode(e, 4, x.uint_contents)
    !isempty(x.uint64_contents) && PB.encode(e, 5, x.uint64_contents)
    !isempty(x.fp32_contents) && PB.encode(e, 6, x.fp32_contents)
    !isempty(x.fp64_contents) && PB.encode(e, 7, x.fp64_contents)
    !isempty(x.bytes_contents) && PB.encode(e, 8, x.bytes_contents)
    return position(e.io) - initpos
end
function PB._encoded_size(x::InferTensorContents)
    encoded_size = 0
    !isempty(x.bool_contents) && (encoded_size += PB._encoded_size(x.bool_contents, 1))
    !isempty(x.int_contents) && (encoded_size += PB._encoded_size(x.int_contents, 2))
    !isempty(x.int64_contents) && (encoded_size += PB._encoded_size(x.int64_contents, 3))
    !isempty(x.uint_contents) && (encoded_size += PB._encoded_size(x.uint_contents, 4))
    !isempty(x.uint64_contents) && (encoded_size += PB._encoded_size(x.uint64_contents, 5))
    !isempty(x.fp32_contents) && (encoded_size += PB._encoded_size(x.fp32_contents, 6))
    !isempty(x.fp64_contents) && (encoded_size += PB._encoded_size(x.fp64_contents, 7))
    !isempty(x.bytes_contents) && (encoded_size += PB._encoded_size(x.bytes_contents, 8))
    return encoded_size
end

struct ServerLiveRequest end

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ServerLiveRequest})
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        PB.skip(d, wire_type)
    end
    return ServerLiveRequest()
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ServerLiveRequest)
    initpos = position(e.io)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ServerLiveRequest)
    encoded_size = 0
    return encoded_size
end

struct ServerReadyResponse
    ready::Bool
end
PB.default_values(::Type{ServerReadyResponse}) = (;ready = false)
PB.field_numbers(::Type{ServerReadyResponse}) = (;ready = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ServerReadyResponse})
    ready = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            ready = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return ServerReadyResponse(ready)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ServerReadyResponse)
    initpos = position(e.io)
    x.ready != false && PB.encode(e, 1, x.ready)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ServerReadyResponse)
    encoded_size = 0
    x.ready != false && (encoded_size += PB._encoded_size(x.ready, 1))
    return encoded_size
end

struct ServerMetadataRequest end

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ServerMetadataRequest})
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        PB.skip(d, wire_type)
    end
    return ServerMetadataRequest()
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ServerMetadataRequest)
    initpos = position(e.io)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ServerMetadataRequest)
    encoded_size = 0
    return encoded_size
end

struct ServerMetadataResponse
    name::String
    version::String
    extensions::Vector{String}
end
PB.default_values(::Type{ServerMetadataResponse}) = (;name = "", version = "", extensions = Vector{String}())
PB.field_numbers(::Type{ServerMetadataResponse}) = (;name = 1, version = 2, extensions = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ServerMetadataResponse})
    name = ""
    version = ""
    extensions = PB.BufferedVector{String}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            version = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, extensions)
        else
            PB.skip(d, wire_type)
        end
    end
    return ServerMetadataResponse(name, version, extensions[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ServerMetadataResponse)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.version) && PB.encode(e, 2, x.version)
    !isempty(x.extensions) && PB.encode(e, 3, x.extensions)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ServerMetadataResponse)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.version) && (encoded_size += PB._encoded_size(x.version, 2))
    !isempty(x.extensions) && (encoded_size += PB._encoded_size(x.extensions, 3))
    return encoded_size
end

struct ModelReadyRequest
    name::String
    version::String
end
PB.default_values(::Type{ModelReadyRequest}) = (;name = "", version = "")
PB.field_numbers(::Type{ModelReadyRequest}) = (;name = 1, version = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ModelReadyRequest})
    name = ""
    version = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            version = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return ModelReadyRequest(name, version)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ModelReadyRequest)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.version) && PB.encode(e, 2, x.version)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ModelReadyRequest)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.version) && (encoded_size += PB._encoded_size(x.version, 2))
    return encoded_size
end

struct ModelMetadataResponse
    name::String
    versions::Vector{String}
    platform::String
    inputs::Vector{var"ModelMetadataResponse.TensorMetadata"}
    outputs::Vector{var"ModelMetadataResponse.TensorMetadata"}
end
PB.default_values(::Type{ModelMetadataResponse}) = (;name = "", versions = Vector{String}(), platform = "", inputs = Vector{var"ModelMetadataResponse.TensorMetadata"}(), outputs = Vector{var"ModelMetadataResponse.TensorMetadata"}())
PB.field_numbers(::Type{ModelMetadataResponse}) = (;name = 1, versions = 2, platform = 3, inputs = 4, outputs = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ModelMetadataResponse})
    name = ""
    versions = PB.BufferedVector{String}()
    platform = ""
    inputs = PB.BufferedVector{var"ModelMetadataResponse.TensorMetadata"}()
    outputs = PB.BufferedVector{var"ModelMetadataResponse.TensorMetadata"}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, versions)
        elseif field_number == 3
            platform = PB.decode(d, String)
        elseif field_number == 4
            PB.decode!(d, inputs)
        elseif field_number == 5
            PB.decode!(d, outputs)
        else
            PB.skip(d, wire_type)
        end
    end
    return ModelMetadataResponse(name, versions[], platform, inputs[], outputs[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ModelMetadataResponse)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.versions) && PB.encode(e, 2, x.versions)
    !isempty(x.platform) && PB.encode(e, 3, x.platform)
    !isempty(x.inputs) && PB.encode(e, 4, x.inputs)
    !isempty(x.outputs) && PB.encode(e, 5, x.outputs)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ModelMetadataResponse)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.versions) && (encoded_size += PB._encoded_size(x.versions, 2))
    !isempty(x.platform) && (encoded_size += PB._encoded_size(x.platform, 3))
    !isempty(x.inputs) && (encoded_size += PB._encoded_size(x.inputs, 4))
    !isempty(x.outputs) && (encoded_size += PB._encoded_size(x.outputs, 5))
    return encoded_size
end

struct var"ModelInferRequest.InferRequestedOutputTensor"
    name::String
    parameters::Dict{String,InferParameter}
end
PB.default_values(::Type{var"ModelInferRequest.InferRequestedOutputTensor"}) = (;name = "", parameters = Dict{String,InferParameter}())
PB.field_numbers(::Type{var"ModelInferRequest.InferRequestedOutputTensor"}) = (;name = 1, parameters = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"ModelInferRequest.InferRequestedOutputTensor"})
    name = ""
    parameters = Dict{String,InferParameter}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, parameters)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"ModelInferRequest.InferRequestedOutputTensor"(name, parameters)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"ModelInferRequest.InferRequestedOutputTensor")
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.parameters) && PB.encode(e, 2, x.parameters)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"ModelInferRequest.InferRequestedOutputTensor")
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.parameters) && (encoded_size += PB._encoded_size(x.parameters, 2))
    return encoded_size
end

struct var"ModelInferRequest.InferInputTensor"
    name::String
    datatype::String
    shape::Vector{Int64}
    parameters::Dict{String,InferParameter}
    contents::Union{Nothing,InferTensorContents}
end
PB.default_values(::Type{var"ModelInferRequest.InferInputTensor"}) = (;name = "", datatype = "", shape = Vector{Int64}(), parameters = Dict{String,InferParameter}(), contents = nothing)
PB.field_numbers(::Type{var"ModelInferRequest.InferInputTensor"}) = (;name = 1, datatype = 2, shape = 3, parameters = 4, contents = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"ModelInferRequest.InferInputTensor"})
    name = ""
    datatype = ""
    shape = PB.BufferedVector{Int64}()
    parameters = Dict{String,InferParameter}()
    contents = Ref{Union{Nothing,InferTensorContents}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            datatype = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, wire_type, shape)
        elseif field_number == 4
            PB.decode!(d, parameters)
        elseif field_number == 5
            PB.decode!(d, contents)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"ModelInferRequest.InferInputTensor"(name, datatype, shape[], parameters, contents[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"ModelInferRequest.InferInputTensor")
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.datatype) && PB.encode(e, 2, x.datatype)
    !isempty(x.shape) && PB.encode(e, 3, x.shape)
    !isempty(x.parameters) && PB.encode(e, 4, x.parameters)
    !isnothing(x.contents) && PB.encode(e, 5, x.contents)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"ModelInferRequest.InferInputTensor")
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.datatype) && (encoded_size += PB._encoded_size(x.datatype, 2))
    !isempty(x.shape) && (encoded_size += PB._encoded_size(x.shape, 3))
    !isempty(x.parameters) && (encoded_size += PB._encoded_size(x.parameters, 4))
    !isnothing(x.contents) && (encoded_size += PB._encoded_size(x.contents, 5))
    return encoded_size
end

struct var"ModelInferResponse.InferOutputTensor"
    name::String
    datatype::String
    shape::Vector{Int64}
    parameters::Dict{String,InferParameter}
    contents::Union{Nothing,InferTensorContents}
end
PB.default_values(::Type{var"ModelInferResponse.InferOutputTensor"}) = (;name = "", datatype = "", shape = Vector{Int64}(), parameters = Dict{String,InferParameter}(), contents = nothing)
PB.field_numbers(::Type{var"ModelInferResponse.InferOutputTensor"}) = (;name = 1, datatype = 2, shape = 3, parameters = 4, contents = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"ModelInferResponse.InferOutputTensor"})
    name = ""
    datatype = ""
    shape = PB.BufferedVector{Int64}()
    parameters = Dict{String,InferParameter}()
    contents = Ref{Union{Nothing,InferTensorContents}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            datatype = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, wire_type, shape)
        elseif field_number == 4
            PB.decode!(d, parameters)
        elseif field_number == 5
            PB.decode!(d, contents)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"ModelInferResponse.InferOutputTensor"(name, datatype, shape[], parameters, contents[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"ModelInferResponse.InferOutputTensor")
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.datatype) && PB.encode(e, 2, x.datatype)
    !isempty(x.shape) && PB.encode(e, 3, x.shape)
    !isempty(x.parameters) && PB.encode(e, 4, x.parameters)
    !isnothing(x.contents) && PB.encode(e, 5, x.contents)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"ModelInferResponse.InferOutputTensor")
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.datatype) && (encoded_size += PB._encoded_size(x.datatype, 2))
    !isempty(x.shape) && (encoded_size += PB._encoded_size(x.shape, 3))
    !isempty(x.parameters) && (encoded_size += PB._encoded_size(x.parameters, 4))
    !isnothing(x.contents) && (encoded_size += PB._encoded_size(x.contents, 5))
    return encoded_size
end

struct ModelInferRequest
    model_name::String
    model_version::String
    id::String
    parameters::Dict{String,InferParameter}
    inputs::Vector{var"ModelInferRequest.InferInputTensor"}
    outputs::Vector{var"ModelInferRequest.InferRequestedOutputTensor"}
    raw_input_contents::Vector{Vector{UInt8}}
end
PB.default_values(::Type{ModelInferRequest}) = (;model_name = "", model_version = "", id = "", parameters = Dict{String,InferParameter}(), inputs = Vector{var"ModelInferRequest.InferInputTensor"}(), outputs = Vector{var"ModelInferRequest.InferRequestedOutputTensor"}(), raw_input_contents = Vector{Vector{UInt8}}())
PB.field_numbers(::Type{ModelInferRequest}) = (;model_name = 1, model_version = 2, id = 3, parameters = 4, inputs = 5, outputs = 6, raw_input_contents = 7)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ModelInferRequest})
    model_name = ""
    model_version = ""
    id = ""
    parameters = Dict{String,InferParameter}()
    inputs = PB.BufferedVector{var"ModelInferRequest.InferInputTensor"}()
    outputs = PB.BufferedVector{var"ModelInferRequest.InferRequestedOutputTensor"}()
    raw_input_contents = PB.BufferedVector{Vector{UInt8}}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            model_name = PB.decode(d, String)
        elseif field_number == 2
            model_version = PB.decode(d, String)
        elseif field_number == 3
            id = PB.decode(d, String)
        elseif field_number == 4
            PB.decode!(d, parameters)
        elseif field_number == 5
            PB.decode!(d, inputs)
        elseif field_number == 6
            PB.decode!(d, outputs)
        elseif field_number == 7
            PB.decode!(d, raw_input_contents)
        else
            PB.skip(d, wire_type)
        end
    end
    return ModelInferRequest(model_name, model_version, id, parameters, inputs[], outputs[], raw_input_contents[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ModelInferRequest)
    initpos = position(e.io)
    !isempty(x.model_name) && PB.encode(e, 1, x.model_name)
    !isempty(x.model_version) && PB.encode(e, 2, x.model_version)
    !isempty(x.id) && PB.encode(e, 3, x.id)
    !isempty(x.parameters) && PB.encode(e, 4, x.parameters)
    !isempty(x.inputs) && PB.encode(e, 5, x.inputs)
    !isempty(x.outputs) && PB.encode(e, 6, x.outputs)
    !isempty(x.raw_input_contents) && PB.encode(e, 7, x.raw_input_contents)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ModelInferRequest)
    encoded_size = 0
    !isempty(x.model_name) && (encoded_size += PB._encoded_size(x.model_name, 1))
    !isempty(x.model_version) && (encoded_size += PB._encoded_size(x.model_version, 2))
    !isempty(x.id) && (encoded_size += PB._encoded_size(x.id, 3))
    !isempty(x.parameters) && (encoded_size += PB._encoded_size(x.parameters, 4))
    !isempty(x.inputs) && (encoded_size += PB._encoded_size(x.inputs, 5))
    !isempty(x.outputs) && (encoded_size += PB._encoded_size(x.outputs, 6))
    !isempty(x.raw_input_contents) && (encoded_size += PB._encoded_size(x.raw_input_contents, 7))
    return encoded_size
end

struct ModelInferResponse
    model_name::String
    model_version::String
    id::String
    parameters::Dict{String,InferParameter}
    outputs::Vector{var"ModelInferResponse.InferOutputTensor"}
    raw_output_contents::Vector{Vector{UInt8}}
end
PB.default_values(::Type{ModelInferResponse}) = (;model_name = "", model_version = "", id = "", parameters = Dict{String,InferParameter}(), outputs = Vector{var"ModelInferResponse.InferOutputTensor"}(), raw_output_contents = Vector{Vector{UInt8}}())
PB.field_numbers(::Type{ModelInferResponse}) = (;model_name = 1, model_version = 2, id = 3, parameters = 4, outputs = 5, raw_output_contents = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ModelInferResponse})
    model_name = ""
    model_version = ""
    id = ""
    parameters = Dict{String,InferParameter}()
    outputs = PB.BufferedVector{var"ModelInferResponse.InferOutputTensor"}()
    raw_output_contents = PB.BufferedVector{Vector{UInt8}}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            model_name = PB.decode(d, String)
        elseif field_number == 2
            model_version = PB.decode(d, String)
        elseif field_number == 3
            id = PB.decode(d, String)
        elseif field_number == 4
            PB.decode!(d, parameters)
        elseif field_number == 5
            PB.decode!(d, outputs)
        elseif field_number == 6
            PB.decode!(d, raw_output_contents)
        else
            PB.skip(d, wire_type)
        end
    end
    return ModelInferResponse(model_name, model_version, id, parameters, outputs[], raw_output_contents[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ModelInferResponse)
    initpos = position(e.io)
    !isempty(x.model_name) && PB.encode(e, 1, x.model_name)
    !isempty(x.model_version) && PB.encode(e, 2, x.model_version)
    !isempty(x.id) && PB.encode(e, 3, x.id)
    !isempty(x.parameters) && PB.encode(e, 4, x.parameters)
    !isempty(x.outputs) && PB.encode(e, 5, x.outputs)
    !isempty(x.raw_output_contents) && PB.encode(e, 6, x.raw_output_contents)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ModelInferResponse)
    encoded_size = 0
    !isempty(x.model_name) && (encoded_size += PB._encoded_size(x.model_name, 1))
    !isempty(x.model_version) && (encoded_size += PB._encoded_size(x.model_version, 2))
    !isempty(x.id) && (encoded_size += PB._encoded_size(x.id, 3))
    !isempty(x.parameters) && (encoded_size += PB._encoded_size(x.parameters, 4))
    !isempty(x.outputs) && (encoded_size += PB._encoded_size(x.outputs, 5))
    !isempty(x.raw_output_contents) && (encoded_size += PB._encoded_size(x.raw_output_contents, 6))
    return encoded_size
end

# TODO: SERVICE
#    GRPCInferenceService
